;; Lisp training, 2011
;; Author: Gurenko Oleg

Главный файл проекта - main.lsp. Он компилирует и подгружает все остальные файлы. Для полноценной работы с проектом достаточно загрузить в компилятор только его.

1. lexer.lsp

Файл содержит лексер для разбора строки согласно указанной грамматики. 

Лексер (lexer) разбивает входную строку в список символов, которые последовательно обрабатывает функция-диспетчер (dispatcher). Разбор и формирование лексем выполняется отдельными функциями, принимающими на вход список символов и возвращающими сформированную лексему и необработанный хвост списка. В хеш-таблицы и переменные вынесены пробелы, цифры, буквы, ключевые слова и разделители, необходимые для формирования лексем.

2. error.lsp

Файл содержит обработчик ошибок. 

Функция (throw-error) выбрасывает ошибку с указанным текстом и местом в списке, на котором возникла эта ошибка. Параметр no-errors показывает, нужно ли выбрасывать ошибку с прерыванием работы программы или просто вернуть nil.

3. tree.lsp

Файл содержит утилиты для работы с синтаксическим деревом разбора согласно указанной грамматики.

Доступные типы нодов дерева:
- var
- id
- num
- expr
- def
- stmt
- stmt*
Также считается, что нода любого типа может быть представлена нодой типа (var) для последующего матчинга.

Функции (make-node-*) создают соответствующие ноды дерева с обязательной проверкой на правильность входящих данных. Функция (make-node) является универсальной и создает ноду с указанным типом.

Функции (node-*-p) выполняют проверку на правильность ноды дерева соответствующего типа. Для проверки операндов данные функции вызывают друг друга рекурсивно, полностью обходя дерево вниз и проверяя все ноды-наследники. Функция (node-p) является универсальной и выполняет проверку указанной ноды на соответствие всем типам. Функция (check-tree) выполняет проверку правильности дерева разбора.

Функции (print-node-*) выполняют печать ноды данного типа, возвращая строку, аналогичную той, что была подана на вход лексера. Функция (print-tree) выполняет печать дерева, рекурсивно вызывая функции печати соответствующих нодов.

Функции (get-*) возвращают соответствующие части ноды, как то: численное значение, идентификатор.

Функции (traverse) выполняет обход дерева, применяя к каждой ноде указанную функцию.

4. parser.lsp

Файл содержит синтаксический анализатор для разбора строки лексем согласно указанной грамматики.

Синтаксический анализатор работает по принципу нисходящего алгоритма синтаксического разбора LL(1). 

Каждому правилу грамматики соответствует отдельная функция, принимающая на вход список лексем, и возвращающая сформированную ноду дерева и хвост из необработанных лексем. Такой подход позволяет использовать данные функции отдельно, для формирования соответствующих нодов дерева, что не позволял первоначальный подход с использованием глобального указателя на текущее место в обрабатываемом списке лексем.

На каждом этапе разбора выполняются проверки, выбрасывающие соответствующие синтаксические ошибки, как то: незакрытые скобки, некорректные входные данные, неожиданные лексемы и т.д. Также в качестве необязательного ключевого параметра каждая функция принимает флаг no-errors, запрещающий выброс ошибок с прерыванием выполнения программы, вместо чего в случае ошибки возвращается nil.

5. match.lsp

Файл содержит функции для выполнения матчинга.

6. parser_utils.lsp

Файл содержит утилиты для работы с парсером и выполнения матчинга.

Переменная *CONTEXT* является списком хеш-таблиц, в которых хранятся переменные var и их значения (ноды) для последующего матчинга.

Функции add-value и get-value соответственно добавляют и возвращают значения переменных из хеш-таблицы, при необходимости и по возможности оборачивая ноду в указанный тип.

Для всех типов нод написаны ридер-макро вида #! <node-type> <string>:
- #! id "a" -> (id a)
- #! num "5" -> (num 5)
- #! expr "1" -> (expr num (num 1))
- #! expr "a" -> (expr id (id a))
- #! expr "1+a" -> (expr add (expr num (num 1)) (expr id (id a)))
- #! def "const a:= 1" -> (def const (id a) (expr num (num 1)))
- #! stmt "1+a;" -> (stmt (expr add (expr num (num 1)) (expr id (id a))))
- #! stmt "const a:= 1;" -> (stmt (def const (id a) (expr num (num 1))))
- #! stmt* "1+a; const a:=1;" -> (stmt* (stmt (expr add (expr num (num 1)) (expr id (id a)))) (stmt* (stmt (def const (id a) (expr num (num 1))))))
Так же считается, что нода любого типа может быть представлена нодой типа (var) для последующего матчинга. Ридер-макро работает с использованием функций парсера, вызывая соответствующие указанному типу функции разбора строки лексем. При несоответствии типа или ошибке разбора выбрасывается синтактическая ошибка.

Для выполнения матчинга написаны макросы (letvar), (forthis) и (/.). Макрос (/.) используется функции (traverse) для обхода дерева и применяет к каждой ноде функцию (forthis) для замены согласно указанным в теле правилам.